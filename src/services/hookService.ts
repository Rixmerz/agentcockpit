/**
 * Hook Service
 *
 * Manages Claude Code hooks for pipeline enforcement.
 * Handles .claude/settings.json and hook scripts.
 */

import { readTextFile, writeTextFile, exists, mkdir, remove } from '@tauri-apps/plugin-fs';
import type { PipelineStep } from '../types';
import { resetPipeline } from './pipelineService';

// Claude settings.json structure
export interface ClaudeHookConfig {
  type: 'command';
  command: string;
  timeout?: number;
}

export interface ClaudeHookMatcher {
  matcher: string;
  hooks: ClaudeHookConfig[];
}

export interface ClaudeSettings {
  hooks?: {
    PreToolUse?: ClaudeHookMatcher[];
    PostToolUse?: ClaudeHookMatcher[];
    [key: string]: ClaudeHookMatcher[] | undefined;
  };
  _pipeline_managed?: boolean;
  [key: string]: unknown;
}

export interface HookResult {
  success: boolean;
  error?: string;
}

// ============================================
// Read/Write Claude Settings
// ============================================

/**
 * Read Claude settings.json from project
 */
export async function readClaudeSettings(projectPath: string): Promise<ClaudeSettings | null> {
  try {
    const settingsPath = `${projectPath}/.claude/settings.json`;
    const fileExists = await exists(settingsPath);

    if (!fileExists) {
      return null;
    }

    const content = await readTextFile(settingsPath);
    return JSON.parse(content);
  } catch (e) {
    console.error('[HookService] Error reading settings:', e);
    return null;
  }
}

/**
 * Write Claude settings.json to project
 */
export async function writeClaudeSettings(
  projectPath: string,
  settings: ClaudeSettings
): Promise<boolean> {
  try {
    const claudeDir = `${projectPath}/.claude`;
    const settingsPath = `${claudeDir}/settings.json`;

    // Ensure .claude directory exists
    const dirExists = await exists(claudeDir);
    if (!dirExists) {
      await mkdir(claudeDir, { recursive: true });
    }

    const content = JSON.stringify(settings, null, 2);
    await writeTextFile(settingsPath, content);
    return true;
  } catch (e) {
    console.error('[HookService] Error writing settings:', e);
    return false;
  }
}

// ============================================
// Pipeline Skill Generation
// ============================================

/**
 * Generate the /pipeline skill for Claude Code
 */
export function generatePipelineSkill(projectPath: string): string {
  return `# Pipeline Management Skill

Gestiona el pipeline de flujo controlado para este proyecto.

## Uso

Este comando acepta los siguientes subcomandos:

- \`/pipeline\` o \`/pipeline status\` - Muestra el estado actual del pipeline
- \`/pipeline advance\` - Avanza al siguiente step
- \`/pipeline reset\` - Resetea el pipeline al Step 0
- \`/pipeline set <n>\` - Va directamente al step n (ej: \`/pipeline set 2\`)

## Instrucciones

Cuando el usuario invoque este comando:

1. **Obtener el project_dir**: Usa \`${projectPath}\` como \`project_dir\`

2. **Ejecutar la acción solicitada** usando el MCP \`pipeline-manager\`:

   - Para **status** (default): Llama a \`mcp__pipeline-manager__pipeline_status\` con \`project_dir="${projectPath}"\`
   - Para **advance**: Llama a \`mcp__pipeline-manager__pipeline_advance\` con \`project_dir="${projectPath}"\`
   - Para **reset**: Llama a \`mcp__pipeline-manager__pipeline_reset\` con \`project_dir="${projectPath}"\`
   - Para **set N**: Llama a \`mcp__pipeline-manager__pipeline_set_step\` con \`project_dir="${projectPath}"\` y \`step_index=N\`

3. **Mostrar el resultado** de forma clara:

   Para status, muestra una tabla con:
   \`\`\`
   Pipeline Status: Step {n} - {nombre}

   | Step | Nombre | Estado | Tools Bloqueados |
   |------|--------|--------|------------------|
   | 0    | ...    | ...    | ...              |
   \`\`\`

   Para otras acciones, confirma la acción realizada.

## Ejemplo de respuesta para status

\`\`\`
Pipeline Status: Step 0 - Complexity Gate

| Step | Nombre              | Estado    | Bloqueados   |
|------|---------------------|-----------|--------------|
| 0    | Complexity Gate     | current   | Write, Edit  |
| 1    | Library Context     | pending   | Write, Edit  |
| 2    | Implementation      | pending   | -            |

Write/Edit bloqueados hasta completar Step 0.
Usa \`/pipeline advance\` para avanzar manualmente.
\`\`\`
`;
}

// Pipeline Enforcer Script Generation
// ============================================

/**
 * Generate the Python pipeline enforcer script
 */
export function generatePipelineEnforcerScript(projectPath: string): string {
  return `#!/usr/bin/env python3
"""
Pipeline Enforcer Hook for Claude Code
Generated by AgentCockpit
"""

import json
import sys
import os
from pathlib import Path

def main():
    # Read hook input from stdin
    try:
        hook_input = json.load(sys.stdin)
    except json.JSONDecodeError:
        # If no input or invalid JSON, approve by default
        print(json.dumps({"decision": "approve"}))
        return

    tool_name = hook_input.get("tool_name", "")

    # Get project directory from environment
    project_dir = os.environ.get("CLAUDE_PROJECT_DIR", "${projectPath}")
    pipeline_dir = Path(project_dir) / ".claude" / "pipeline"

    # Read current state
    state_file = pipeline_dir / "state.json"
    steps_file = pipeline_dir / "steps.yaml"

    if not state_file.exists() or not steps_file.exists():
        # No pipeline configured, approve all
        print(json.dumps({"decision": "approve"}))
        return

    try:
        with open(state_file, 'r') as f:
            state = json.load(f)

        current_step = state.get("current_step", 0)

        # Parse steps.yaml to get current step config
        # Simple YAML parsing (basic implementation)
        with open(steps_file, 'r') as f:
            steps_content = f.read()

        # Extract tools_blocked for current step
        steps = parse_steps_yaml(steps_content)

        if current_step < len(steps):
            step = steps[current_step]
            tools_blocked = step.get("tools_blocked", [])

            # Check if tool is blocked
            if tool_name in tools_blocked:
                print(json.dumps({
                    "decision": "block",
                    "message": f"Tool '{tool_name}' is blocked at step {current_step} ({step.get('name', 'Unknown')}). Complete this step first."
                }))
                return
    except Exception as e:
        # On error, approve to avoid blocking legitimate work
        print(json.dumps({"decision": "approve"}))
        return

    print(json.dumps({"decision": "approve"}))

def parse_steps_yaml(content: str) -> list:
    """Simple YAML parser for steps configuration"""
    steps = []
    current_step = None
    current_list = None

    for line in content.split('\\n'):
        stripped = line.strip()

        if not stripped or stripped.startswith('#'):
            continue

        if stripped.startswith('- id:'):
            if current_step is not None:
                steps.append(current_step)
            # Extract id value
            id_val = stripped.split(':', 1)[1].strip().strip('"').strip("'")
            current_step = {"id": id_val, "tools_blocked": [], "mcps_enabled": []}
            current_list = None
            continue

        if current_step is not None:
            if stripped.startswith('- ') and current_list:
                value = stripped[2:].strip().strip('"').strip("'")
                current_step[current_list].append(value)
            elif ':' in stripped:
                key, val = stripped.split(':', 1)
                key = key.strip()
                val = val.strip().strip('"').strip("'")

                if not val:
                    current_list = key
                    if key not in current_step:
                        current_step[key] = []
                else:
                    current_step[key] = val
                    current_list = None

    if current_step is not None:
        steps.append(current_step)

    return steps

if __name__ == "__main__":
    main()
`;
}

// ============================================
// Hook Installation
// ============================================

/**
 * Install pipeline hooks into a project
 */
export async function installPipelineHooks(
  projectPath: string,
  _steps?: PipelineStep[]  // Kept for future use (e.g., generating step-specific hooks)
): Promise<HookResult> {
  try {
    // 1. Ensure .claude/hooks directory exists
    const hooksDir = `${projectPath}/.claude/hooks`;
    const hooksDirExists = await exists(hooksDir);
    if (!hooksDirExists) {
      await mkdir(hooksDir, { recursive: true });
    }

    // 2. Generate and write enforcer script
    const enforcerPath = `${hooksDir}/pipeline_enforcer.py`;
    const enforcerScript = generatePipelineEnforcerScript(projectPath);
    await writeTextFile(enforcerPath, enforcerScript);

    // 2.5. Initialize pipeline state (state.json at step 0)
    await resetPipeline(projectPath);
    console.log('[HookService] Pipeline state initialized at step 0');

    // 2.6. Create /pipeline skill for Claude Code
    const commandsDir = `${projectPath}/.claude/commands`;
    const commandsDirExists = await exists(commandsDir);
    if (!commandsDirExists) {
      await mkdir(commandsDir, { recursive: true });
    }
    const skillPath = `${commandsDir}/pipeline.md`;
    const skillContent = generatePipelineSkill(projectPath);
    await writeTextFile(skillPath, skillContent);
    console.log('[HookService] Pipeline skill created');

    // 3. Read existing settings (preserve other hooks)
    let settings = await readClaudeSettings(projectPath) || {};

    // 4. Add pipeline hook configuration
    const pipelineHook: ClaudeHookConfig = {
      type: 'command',
      command: `python3 "$CLAUDE_PROJECT_DIR/.claude/hooks/pipeline_enforcer.py"`,
      timeout: 5
    };

    const pipelineMatcher: ClaudeHookMatcher = {
      matcher: '*',
      hooks: [pipelineHook]
    };

    // Initialize hooks if not present
    if (!settings.hooks) {
      settings.hooks = {};
    }

    // Get existing PreToolUse hooks (filter out any previous pipeline hooks)
    const existingPreToolUse = (settings.hooks.PreToolUse || []).filter(
      matcher => !matcher.hooks.some(h => h.command.includes('pipeline_enforcer'))
    );

    // Add pipeline matcher
    settings.hooks.PreToolUse = [...existingPreToolUse, pipelineMatcher];
    settings._pipeline_managed = true;

    // 5. Write settings
    const success = await writeClaudeSettings(projectPath, settings);

    if (!success) {
      return { success: false, error: 'Failed to write settings.json' };
    }

    console.log('[HookService] Pipeline hooks installed successfully');
    return { success: true };
  } catch (e) {
    const error = e instanceof Error ? e.message : String(e);
    console.error('[HookService] Install error:', error);
    return { success: false, error };
  }
}

/**
 * Uninstall pipeline hooks from a project
 */
export async function uninstallPipelineHooks(projectPath: string): Promise<HookResult> {
  try {
    // 1. Read existing settings
    const settings = await readClaudeSettings(projectPath);

    if (settings && settings.hooks) {
      // Remove pipeline hooks from PreToolUse
      if (settings.hooks.PreToolUse) {
        settings.hooks.PreToolUse = settings.hooks.PreToolUse.filter(
          matcher => !matcher.hooks.some(h => h.command.includes('pipeline_enforcer'))
        );

        // Clean up empty array
        if (settings.hooks.PreToolUse.length === 0) {
          delete settings.hooks.PreToolUse;
        }
      }

      // Clean up empty hooks object
      if (Object.keys(settings.hooks).length === 0) {
        delete settings.hooks;
      }

      delete settings._pipeline_managed;

      // Write updated settings
      await writeClaudeSettings(projectPath, settings);
    }

    // 2. Remove enforcer script
    const enforcerPath = `${projectPath}/.claude/hooks/pipeline_enforcer.py`;
    const enforcerExists = await exists(enforcerPath);
    if (enforcerExists) {
      await remove(enforcerPath);
    }

    console.log('[HookService] Pipeline hooks uninstalled successfully');
    return { success: true };
  } catch (e) {
    const error = e instanceof Error ? e.message : String(e);
    console.error('[HookService] Uninstall error:', error);
    return { success: false, error };
  }
}

// ============================================
// Hook Status
// ============================================

/**
 * Check if pipeline hooks are installed in a project
 */
export async function isPipelineHooksInstalled(projectPath: string): Promise<boolean> {
  try {
    const settings = await readClaudeSettings(projectPath);

    if (!settings || !settings.hooks || !settings.hooks.PreToolUse) {
      return false;
    }

    // Check if pipeline hook is present
    return settings.hooks.PreToolUse.some(
      matcher => matcher.hooks.some(h => h.command.includes('pipeline_enforcer'))
    );
  } catch (e) {
    console.error('[HookService] Error checking installation:', e);
    return false;
  }
}

/**
 * Sync pipeline hooks based on enabled state
 */
export async function syncPipelineHooks(
  projectPath: string,
  enabled: boolean,
  steps: PipelineStep[]
): Promise<HookResult> {
  if (enabled) {
    return await installPipelineHooks(projectPath, steps);
  } else {
    return await uninstallPipelineHooks(projectPath);
  }
}

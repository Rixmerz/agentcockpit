#!/usr/bin/env python3
"""
Pipeline Enforcer Hook for Claude Code
Generated by AgentCockpit
"""

import json
import sys
import os
from pathlib import Path

def main():
    # Read hook input from stdin
    try:
        hook_input = json.load(sys.stdin)
    except json.JSONDecodeError:
        # If no input or invalid JSON, approve by default
        print(json.dumps({"decision": "approve"}))
        return

    tool_name = hook_input.get("tool_name", "")

    # Get project directory from environment
    project_dir = os.environ.get("CLAUDE_PROJECT_DIR", "/Users/juanpablodiaz/my_projects/agentcockpit")
    pipeline_dir = Path(project_dir) / ".claude" / "pipeline"

    # Check if enforcer is enabled via config
    config_file = pipeline_dir / "config.json"
    if config_file.exists():
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
            if not config.get("enforcer_enabled", True):
                # Enforcer is disabled, approve all
                print(json.dumps({"decision": "approve"}))
                return
        except Exception:
            pass  # If config read fails, continue with normal logic

    # Read current state
    state_file = pipeline_dir / "state.json"
    steps_file = pipeline_dir / "steps.yaml"

    if not state_file.exists() or not steps_file.exists():
        # No pipeline configured, approve all
        print(json.dumps({"decision": "approve"}))
        return

    try:
        with open(state_file, 'r') as f:
            state = json.load(f)

        current_step = state.get("current_step", 0)

        # Parse steps.yaml to get current step config
        # Simple YAML parsing (basic implementation)
        with open(steps_file, 'r') as f:
            steps_content = f.read()

        # Extract tools_blocked for current step
        steps = parse_steps_yaml(steps_content)

        if current_step < len(steps):
            step = steps[current_step]
            tools_blocked = step.get("tools_blocked", [])

            # Check if tool is blocked
            if tool_name in tools_blocked:
                print(json.dumps({
                    "decision": "block",
                    "message": f"Tool '{tool_name}' is blocked at step {current_step} ({step.get('name', 'Unknown')}). Complete this step first."
                }))
                return
    except Exception as e:
        # On error, approve to avoid blocking legitimate work
        print(json.dumps({"decision": "approve"}))
        return

    print(json.dumps({"decision": "approve"}))

def parse_steps_yaml(content: str) -> list:
    """Simple YAML parser for steps configuration"""
    steps = []
    current_step = None
    current_list = None

    for line in content.split('\n'):
        stripped = line.strip()

        if not stripped or stripped.startswith('#'):
            continue

        if stripped.startswith('- id:'):
            if current_step is not None:
                steps.append(current_step)
            # Extract id value
            id_val = stripped.split(':', 1)[1].strip().strip('"').strip("'")
            current_step = {"id": id_val, "tools_blocked": [], "mcps_enabled": []}
            current_list = None
            continue

        if current_step is not None:
            if stripped.startswith('- ') and current_list:
                value = stripped[2:].strip().strip('"').strip("'")
                current_step[current_list].append(value)
            elif ':' in stripped:
                key, val = stripped.split(':', 1)
                key = key.strip()
                val = val.strip().strip('"').strip("'")

                if not val:
                    current_list = key
                    if key not in current_step:
                        current_step[key] = []
                else:
                    current_step[key] = val
                    current_list = None

    if current_step is not None:
        steps.append(current_step)

    return steps

if __name__ == "__main__":
    main()
